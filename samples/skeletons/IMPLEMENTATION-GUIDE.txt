================================================================================
NEWGROUNDS.IO PSEUDO-CODE IMPLEMENTATION GUIDE
================================================================================

This document provides essential guidance for translating the pseudo-code files
into working code for your target platform. It's designed to to fill knowledge 
gaps and eliminate assumptions.

TARGET AUDIENCE:
- Developers implementing their first Newgrounds.io library
- AI/LLM-based code generators translating pseudo-code
- Contributors working in unfamiliar languages
- Developers seeking clarification on design decisions

IMPORTANT: If you are using AI/LLM assistance (Claude, ChatGPT, etc.), please
read the "AI/LLM TRANSLATION GUIDANCE" section before beginning translation.

================================================================================
CORE CONCEPTS
================================================================================

WHAT IS NEWGROUNDS.IO?
----------------------
Newgrounds.io is a server-side API that provides game services like:
- User authentication (Passport system)
- Achievements/Medals
- Leaderboards/Scoreboards  
- Cloud saves
- Analytics and event tracking

All communication happens via HTTPS POST requests to a single gateway endpoint.
Your library acts as a wrapper that formats requests, handles responses, and
manages local state caching.


ASYNCHRONOUS OPERATIONS
------------------------
All network communication is asynchronous - functions return immediately while
the actual work happens in the background.

CALLBACKS vs PROMISES:
- Pseudo-code uses callback pattern: function(result, error)
- If your language/platform prefers Promises, use them instead
- If your language prefers async/await, use that instead
- Choose whichever pattern is STANDARD for your platform

EXAMPLES:
JavaScript (modern):    async/await with Promises
JavaScript (classic):   Callbacks
Python:                 async/await with asyncio
C#:                     async/await with Tasks
Java:                   CompletableFuture or callbacks
Swift:                  async/await or completion handlers

THE RULE: Use what developers in your language expect to see.


CALLBACK SCOPE BINDING
----------------------
If using callbacks and your language doesn't have arrow functions or .bind():
- Add optional "thisArg" or "bindTo" parameter to methods
- Example: unlock(callback, thisArg) instead of unlock(callback)
- This lets developers maintain proper 'this' context


NULL vs UNDEFINED vs NONE
--------------------------
Pseudo-code uses "null" for empty/missing values.
Translate to your language's equivalent:
- JavaScript: null or undefined (prefer null for consistency)
- Python: None
- Java: null
- C#: null
- Ruby: nil
- Go: nil


================================================================================
AI/LLM TRANSLATION GUIDANCE
================================================================================

CRITICAL: The pseudo-code files (especially NGIO.pseudo) are very large and contain
many methods. AI models with limited context windows may skip or miss methods in
the middle sections of files due to attention degradation.

RECOMMENDED TRANSLATION PROCESS
-------------------------------

STEP 1: INVENTORY-FIRST APPROACH
Before translating any code, create a complete inventory:

1. Read the entire skeleton file carefully
2. Create an itemized list of ALL properties, methods, and constants
3. Note which sections they belong to (e.g., "Session Management", "Medals", etc.)
4. Save this list as your translation checklist

STEP 2: CHUNKED TRANSLATION
Translate in manageable chunks to maintain accuracy:

1. Translate methods 1-15 from your inventory list
2. After completing each chunk, LIST what methods you just added
3. VERIFY against your inventory what still needs translation
4. Translate methods 16-30 from your inventory list
5. Repeat until all methods are complete

STEP 3: PROGRESSIVE VALIDATION
After each chunk:

1. List the specific methods you just translated
2. Cross them off your inventory checklist
3. Explicitly state what sections/methods remain
4. Don't proceed until you confirm the previous chunk is complete

STEP 4: EXPLICIT COVERAGE VERIFICATION
Before finalizing your translation:

1. Use search tools to verify ALL methods from your inventory exist in the final code
2. Search for each method name individually to confirm it was implemented
3. Compare the method count in your final code to your original inventory
4. Flag any discrepancies and resolve them

STEP 5: FINAL COMPLETENESS CHECK
Perform these verification steps:

1. Search your translated code for "TODO" or placeholder text
2. Verify all imports/dependencies are included
3. Confirm all classes extend the correct base classes
4. Test that the code compiles/runs without errors
5. Compare your translation against the original pseudo-code structure

COMMON PITFALLS FOR AI TRANSLATION
-----------------------------------

1. ATTENTION DEGRADATION: Large files cause AI models to lose focus on middle sections
   → Solution: Use the chunked approach above

2. ASSUMING COMPLETION: AI models often think they've translated everything when they haven't
   → Solution: Explicitly verify every method against your inventory

3. PLACEHOLDER POLLUTION: AI models sometimes leave "TODO" comments or incomplete implementations
   → Solution: Search for and resolve all placeholders before finishing

4. INCONSISTENT PATTERNS: Different sections translated with different coding styles
   → Solution: Establish coding patterns in the first chunk and maintain them throughout

5. MISSING ERROR HANDLING: AI models often skip or simplify error handling logic
   → Solution: Pay special attention to error handling patterns in the pseudo-code

EXAMPLE INVENTORY FORMAT
------------------------
Create a checklist like this for each file:

NGIO.pseudo Translation Checklist:
□ init() method
□ hasSession() method  
□ hasUser() method
□ getUser() method
□ openPassport() method
□ keepAlive() method
□ checkSession() method
□ endSession() method
□ loadAppData() method
□ getGatewayVersion() method
□ loadGatewayVersion() method
□ getCurrentVersion() method
□ loadCurrentVersion() method
□ getClientDeprecated() method
□ loadClientDeprecated() method
□ getHostApproved() method
□ loadHostApproved() method
□ getMedals() method
□ loadMedals() method
□ getMedalScore() method
□ loadMedalScore() method
□ getMedal() method
□ getScoreBoards() method
□ loadScoreBoards() method
□ getScoreBoard() method
□ getSaveSlots() method
□ loadSaveSlots() method
□ getSaveSlot() method
□ loadGatewayDateTime() method
□ loadGatewayTimestamp() method
□ sendPing() method
□ logEvent() method
□ openOfficialUrl() method
□ loadOfficialUrl() method
□ openAuthorUrl() method
□ loadAuthorUrl() method
□ openMoreGames() method
□ loadMoreGames() method
□ openNewgrounds() method
□ loadNewgrounds() method
□ openReferral() method
□ loadReferral() method
□ startKeepAliveTimer() method
□ All constants (CHECKSESSION_THROTTLE_TIME, KEEP_ALIVE_TIME)
□ All static properties (core, lastCheckSessionTime, lastKeepAliveTime)

Remember: This checklist should be created by carefully reading the ENTIRE file first.


================================================================================
LANGUAGE-SPECIFIC ADAPTATIONS
================================================================================

NAMING CONVENTIONS
------------------
Pseudo-code uses conventions that may not match your language:

Classes:        PascalCase - Adapt to your language's convention
Methods:        camelCase - Adapt to your language's convention  
Properties:     camelCase - Adapt to your language's convention
Constants:      SCREAMING_SNAKE_CASE - Usually keep this

EXAMPLES:
Python:         class_names, method_names, property_names
Ruby:           ClassNames, method_names, @instance_vars
Go:             StructNames, MethodNames, fieldNames
Rust:           StructNames, method_names, field_names

THE RULE: Follow the dominant style guide for your language/platform.


NAMESPACE STRUCTURE
-------------------
Pseudo-code uses dot notation: NewgroundsIO.models.objects.Medal

Translate to your language's namespace/module system:
- JavaScript (ES6):     NewgroundsIO.models.objects.Medal (class structure)
- Python:               newgrounds_io.models.objects.Medal (modules)
- Java:                 com.newgrounds.io.models.objects.Medal (packages)
- C#:                   NewgroundsIO.Models.Objects.Medal (namespaces)
- Ruby:                 NewgroundsIO::Models::Objects::Medal (modules)
- Go:                   newgroundsio/models/objects/medal.go (packages)

THE RULE: Use your language's standard module/package conventions.


STATIC vs INSTANCE
------------------
Pseudo-code indicates when classes should be static/singleton:
- "This is a static class" = All methods/properties are class-level
- "This is a singleton" = Only one instance should exist

Languages handle this differently:
- JavaScript: Use class with static methods, or singleton pattern
- Python: Use module-level functions, or class with @classmethod
- Java: Use private constructor + getInstance(), or all static
- C#: Use sealed class with private constructor + static Instance property

THE RULE: Use your language's idiomatic approach to static/singleton.


TYPE SYSTEMS
------------
Pseudo-code includes type hints for clarity: "appId: string"

Strongly-typed languages:
- Use explicit types matching pseudo-code hints
- string - String/string/str
- number/int - int/Integer/int32/i32
- number/float - float/double/f64
- boolean - bool/boolean/Boolean
- array - List<T>/Array<T>/Vec<T>/[]T
- object/dictionary - Map<K,V>/Dictionary<K,V>/HashMap<K,V>

Dynamically-typed languages:
- Type hints are documentation only
- Use type hints in comments or docstrings
- Consider optional type hints (Python type annotations, JSDoc, etc.)

THE RULE: Leverage your type system appropriately.


================================================================================
NETWORK COMMUNICATION
================================================================================

SSL/HTTPS REQUIREMENT
---------------------
ALL communication with the Newgrounds.io gateway MUST use HTTPS (SSL/TLS).

IMPORTANT POINTS:
- Gateway URL: https://www.newgrounds.io/gateway_v3.php (note HTTPS)
- The server prefers HTTPS and may reject HTTP requests
- Your HTTP library must support HTTPS (virtually all modern ones do)
- You don't need to implement SSL yourself - just use HTTPS URLs
- Certificates are handled automatically by HTTP libraries

Most platforms provide HTTPS support out of the box:
- Browsers: Fetch API and XMLHttpRequest support HTTPS natively
- Node.js: https module or fetch/axios libraries
- Python: requests library handles HTTPS automatically
- Java: HttpClient supports HTTPS by default
- C#: HttpClient supports HTTPS by default
- Game engines: Built-in HTTP APIs typically support HTTPS

If your platform lacks HTTPS support, it cannot communicate with Newgrounds.io.

THE RULE: Always use the full HTTPS URL. Don't try to use HTTP.


NETWORK PERMISSIONS AND SECURITY POLICIES
-----------------------------------------
Some platforms require explicit network permissions or policy files before
making HTTPS requests. The pseudo-code uses these generic helpers:

PLATFORM NOTES:
- Flash/AIR: load crossdomain policy files and allow network domains
- Web browsers: no policy file, but CORS rules still apply
- Mobile apps: ensure manifest permissions for network access
- Desktop apps: ensure firewall or sandbox policies allow HTTPS

If your platform does not require these steps, make the helpers no-ops.


HTTP POST METHODS
-----------------
The gateway accepts requests in TWO formats - use whichever your platform supports:

METHOD 1: Raw Body POST (Preferred for modern platforms)
- POST the JSON string directly as the request body
- Content-Type: application/json (or text/plain)
- Example: fetch(url, {method: 'POST', body: jsonString})

METHOD 2: Form Data POST (Required for many game engines)
- POST using form-urlencoded format
- Send JSON string as a parameter named "request"
- Content-Type: application/x-www-form-urlencoded
- Example: POST "request=" + urlEncode(jsonString)

PLATFORMS:
- JavaScript (browser/Node): Use Fetch API (Method 1)
- Unity (C#): Use UnityWebRequest with form (Method 2)
- GameMaker: Use http_post_string with form (Method 2)
- Python: Use requests library (Method 1 or 2)
- Java: Use HttpClient (Method 1 or 2)

THE RULE: Both methods work equally well. Use what your platform provides.


HANDLING RESPONSES
------------------
All successful responses are JSON objects containing:
- success: boolean (true if request was valid)
- result: object or array (the actual data)
- error: object (only present if success is false)

Your code must:
1. Check HTTP status code (200-299 = success, else = error)
2. Parse response text as JSON
3. Check response.success property
4. Handle response.error if present
5. Process response.result data

ERROR HANDLING:
- Network errors: No response received (timeout, no connection)
- HTTP errors: Bad status code (400, 500, etc.)
- API errors: success=false with error object
- Parse errors: Invalid JSON in response

Handle all four types gracefully.


================================================================================
ENCRYPTION
================================================================================

ENCRYPTION REQUIREMENTS
-----------------------
Components that modify user data (medal unlocks, score posts) support encryption
to prevent cheating. The pseudo-code indicates this with "isSecure" property.

SUPPORTED CIPHERS:
1. AES-128-CBC (STRONGLY PREFERRED)
   - Block cipher, 128-bit key
   - Requires initialization vector (IV)
   - Most secure option

2. RC4 (FALLBACK ONLY)
   - Stream cipher, 128-bit key
   - Simpler but less secure
   - Use only if AES is unavailable

ENCODING:
- Encryption produces binary data
- Must be encoded to string for transmission
- Base64 (preferred) or Hexadecimal
- Pseudo-code uses "ENCODE_BASE64_OR_HEX()"

IMPLEMENTATION:
If your platform lacks native encryption:
- Use a well-established crypto library
- Do NOT implement encryption yourself
- If no library exists, document this limitation
- Projects can be configured to work without encryption

KEYS:
- Encryption key provided by Newgrounds (from app settings)
- Key format depends on cipher and encoding choices
- May need to decode key from Base64/Hex before use

Newgrounds projects assume AES-128 with Base64 encoding by default.
Be very clear if another cypher and/or encoder are used, 
or if encryption is not implemented.

================================================================================
STATE MANAGEMENT
================================================================================

THE APPSTATE PATTERN
--------------------
AppState caches server data locally (medals, scoreboards, sessions, etc.) to
minimize network requests. This is CRITICAL for performance.

KEY CONCEPTS:

1. OBSERVER PATTERN
   - Don't replace object references when updating
   - Use importFromObject() to update properties in-place
   - This lets external code keep references to objects

2. LOADED DATA TRACKING
   - Track which data types have been loaded
   - hasLoaded('medals') returns true after loadMedals() completes
   - Prevents redundant loads and provides clear state

3. AUTOMATIC UPDATES
   - Response.importFromObject() calls appState.setValueFromResult()
   - This automatically updates cached data from server responses
   - Developers don't manually sync state

WHY THIS MATTERS:
- Game code can call NGIO.getMedal(5) instantly after loading medals once
- No network delay for cached data
- References stay valid even after updates
- Clear distinction between cached and uncached data


SESSION MANAGEMENT
------------------
Sessions link users to your app. Critical points:

1. SESSION LIFECYCLE
   - Created by App.startSession or loaded from URL/storage
   - Validated with App.checkSession before trusting user data
   - Expires after 1 hour (or 30 days if "remember" is true)
   - Renewed on every API request containing the session ID

2. PASSPORT FLOW
   - session.passport_url opens browser window for login
   - User logs in on Newgrounds website
   - Must poll with App.checkSession to detect completion
   - Session.user property populated when login succeeds

3. SESSION STORAGE
   - If session.remember is true, save session.id locally
   - Restore on app launch and validate with App.checkSession
   - Clear storage if session expired or user logs out

4. VERIFIED PROPERTY (CUSTOM)
   - Add custom "verified" boolean property to Session model
   - Set false when creating a session model
   - Set true after App.checkSession or App.startSession succeeds
   - Prevents using unvalidated sessions


================================================================================
MODEL GENERATION
================================================================================

OBJECT, COMPONENT, AND RESULT MODELS
-------------------------------------
The API has many models - manually coding each is tedious and error-prone.

OPTIONS:

1. AUTOMATED GENERATION (Recommended)
    - This guide is bundled with the official model generator library
    - See: https://github.com/PsychoGoldfishNG/ngio-object-model-generator
    - The generator uses official JSON schema from Newgrounds.io
    - Can be customized to fit most languages.
    - Follow the generator's documentation for details
    - Generates templates that can render all models with properties, types, and validation

2. MANUAL IMPLEMENTATION
   - Follow the Newgrounds.io Developer Guide: https://github.com/PsychoGoldfishNG/ngio-developer-guide
   - Use web documentation: https://www.newgrounds.io/help/
   - Objects list: https://www.newgrounds.io/help/objects
   - Components list: https://www.newgrounds.io/help/components/
   - More time-consuming but gives you full control


GENERATOR WORKFLOW (IMPORTANT)
------------------------------
When using the official model generator, understand which files are meant to be
edited and which are regenerated:

SCAFFOLD FILES (Convert once, then safe to edit):
- NGIO.xxx, Core.xxx, AppState.xxx, Errors.xxx, SessionStatus.xxx
- BaseObject.xxx, BaseComponent.xxx, BaseResult.xxx (in NewgroundsIO/)
- Templates (object.ejs, component.ejs, etc.)
- Partials (custom code for specific objects)
- config.js and helpers.js

These files are copied during scaffolding and translated to your language ONCE.
After translation, you can freely edit them - they won't be overwritten.

MODEL FILES (Regenerated on each build - DO NOT EDIT MANUALLY):
- Everything in the NewgroundsIO/models/ subdirectory
- Objects (NewgroundsIO/models/objects/Medal.xxx, User.xxx, Session.xxx, etc.)
- Components (NewgroundsIO/models/components/Medal/unlock.xxx, etc.)
- Results (NewgroundsIO/models/results/Medal/unlock.xxx, etc.)

Note: Base classes (BaseObject, BaseComponent, BaseResult) are NOT in the models/
subdirectory - they live in the NewgroundsIO/ directory alongside Core and AppState,
so they are safe to edit and won't be regenerated.

These model files are regenerated every time you run ngio-build. Any manual edits
will be lost. To customize these, use partials or modify the templates instead.

WORKFLOW:
1. Run ngio-scaffold once
2. Translate scaffold files to your language (including base classes)
3. Customize templates for your needs
4. Run ngio-build (regenerates NewgroundsIO/models/ only)
5. Run ngio-build again when API changes (regenerates NewgroundsIO/models/ only)
6. Continue editing scaffold files as needed - they're yours to maintain

BASE CLASSES:
All models extend one of three base classes:
- BaseObject: For data objects (User, Medal, Session, etc.)
- BaseComponent: For component definitions (Medal.unlock, etc.)
- BaseResult: For component results

Each base class provides:
- Type validation and casting
- JSON serialization/deserialization
- Property tracking
- Consistent interface

The base classes are scaffold files (in NewgroundsIO/, not in models/) that you
translate once and can then edit freely. They will not be regenerated.

Refer to model generator documentation for details on specific models.


MIXED TYPE PROPERTIES
----------------------
Some properties accept either a single value OR an array of values.
Example: Request.execute can be one Execute object or an array of Executes.

IMPLEMENTATION PATTERN:
1. Create TWO internal properties: "execute" and "executeList"
2. Create setters: setExecute(value) and setExecuteList(array)
3. Only ONE should be set at a time (setters clear the other)
4. Create helpers: executeIsArray(), getExecute(), getExecuteList()
5. Override prepareForJson() to output the correct format

This ensures type safety while supporting the API's flexibility.


OBJECT CREATION PATTERNS
-------------------------
The skeleton files contain conditional logic for object creation. You must choose
ONE pattern based on whether your implementation will include an ObjectFactory.

IMPORTANT FOR AI/LLM TRANSLATORS: 
If you are using AI assistance to translate these skeletons, ALWAYS prompt the
user to choose which pattern they prefer before beginning translation. The 
ObjectFactory may not exist when translating skeletons, so user choice is critical.

PATTERN 1: OBJECTFACTORY PATTERN (Strongly Recommended)

When to use:
- Your language has strong typing
- You want centralized object creation
- You plan to use the model generator to create an ObjectFactory
- You need runtime type resolution by name

Implementation:
- Translate all "IF ObjectFactory exists" branches
- Remove all "ELSE" branches for direct creation
- Rely on ObjectFactory.CreateObject() and ObjectFactory.CreateComponent()
- ObjectFactory handles type mapping and instantiation

Example pseudo-code translation:
```
// Skeleton shows:
IF ObjectFactory exists AND ObjectFactory.CreateObject exists THEN
    SET medal TO ObjectFactory.CreateObject("Medal", medalData, this.core)
ELSE
    SET medal TO new Medal()
    CALL medal.importFromObject(medalData)
END IF

// Pattern 1 translation (ObjectFactory):
medal = ObjectFactory.CreateObject("Medal", medalData, this.core);
```

PATTERN 2: DIRECT CREATION PATTERN (Okay for some dynamically-typed languages)

When to use:
- Your language has dynamic typing or weak typing
- You prefer simple, direct object creation
- You want to avoid the complexity of a factory system
- Smaller libraries or simpler implementations

Implementation:
- Translate all "ELSE" branches for direct creation
- Remove all "IF ObjectFactory exists" branches  
- Use direct constructor calls: new Medal(), new User(), etc.
- Handle object initialization manually

Example pseudo-code translation:
```
// Skeleton shows:
IF ObjectFactory exists AND ObjectFactory.CreateObject exists THEN
    SET medal TO ObjectFactory.CreateObject("Medal", medalData, this.core)
ELSE
    SET medal TO new Medal()
    CALL medal.importFromObject(medalData)
END IF

// Pattern 2 translation (Direct Creation):
medal = new Medal();
medal.importFromObject(medalData);
```

CHOOSING YOUR PATTERN:

Ask these questions:
1. Does your language have strong typing? (ObjectFactory recommended)
2. Do you want centralized object creation? (ObjectFactory recommended)
3. Are you building a large, complex library? (ObjectFactory recommended)
4. Do you prefer simplicity over features? (Direct Creation recommended)
5. Are you using the model generator? (ObjectFactory available)

CRITICAL: Be consistent throughout your entire implementation. Don't mix patterns.

AI/LLM PROMPT TEMPLATE:
"Before I translate the Newgrounds.io skeletons, I need to choose an object 
creation pattern. The skeletons support two approaches:

1. ObjectFactory Pattern - Uses centralized factory for all object creation
2. Direct Creation Pattern - Uses direct constructor calls (new Object())

Which pattern would you prefer for this implementation? Consider:
- Language typing system (strong vs dynamic)
- Library complexity preferences  
- Whether you'll use the model generator

Please specify your preference so I can translate the conditional logic correctly."


================================================================================
DEBUGGING AND TESTING
================================================================================

DEBUG MODE
----------
Core.useDebugMode = true makes components execute without saving to server.
- Medal unlocks show success but don't actually unlock
- Scores post successfully but don't save to leaderboard
- Useful for testing without polluting real data
- Always document this feature for users

COMMON ISSUES:

1. Debug mode left enabled in production
    - Core.useDebugMode = true prevents actual data saves
    - Medals don't unlock, scores don't post to leaderboard
    - Always disable before shipping (set to false or remove)

2. Session not validated before use
    - Newgrounds passes authenticated session_id in URL on hosted games
    - CRITICAL: Must call App.checkSession() and wait for callback before using session.user
    - Common mistake: Trying to unlock medals on title screen before session validates
    - Always ensure hasLoaded('session') is true and session.user is not null

3. "Session expired" errors
    - Session IDs expire after 1 hour (or 30 days if remembered)
    - Always validate sessions before trusting them

4. "Login required" errors
    - Component requires authenticated user
    - Check session.user is not null before calling

5. Encryption failures
    - Wrong cipher or encoding format
    - Verify encryption settings match app configuration

6. "Invalid app ID" errors
    - Wrong app ID or encryption key
    - Double-check credentials from Newgrounds

7. CORS errors (web browsers)
    - Newgrounds.io has wide-open CORS headers
    - Errors typically occur when running locally (file://) or using HTTP
    - Always use HTTPS and a proper domain/localhost server
    - Use a local dev server (not file://) for testing

TESTING CHECKLIST:
[] Can initialize Core with app credentials
[] Can load medals, scoreboards, save slots
[] Can unlock medal (creates encrypted request)
[] Can post scoreboard value (creates encrypted request)
[] Can handle expired session gracefully
[] Can open Passport URL and detect login completion
[] Can save and restore session from storage
[] Can handle network errors gracefully
[] Can parse all response formats correctly


================================================================================
PLATFORM-SPECIFIC CONSIDERATIONS
================================================================================

WEB BROWSERS
------------
- Use Fetch API or XMLHttpRequest for network
- Respect CORS (Newgrounds.io has proper headers)
- Extract session ID from URL query string on page load (if present)
- Use localStorage for session persistence
- Open Passport in a new browser tab.

GAME ENGINES (Unity, Unreal, GameMaker, etc.)
----------------------------------------------
- Use engine's HTTP API (often form-based POST only)
- Will need separate window/tab for Passport
- Check for session ID in launch parameters
- Use engine's persistent storage for sessions
- May lack native JSON and/or encryption (use plugins)

TIMER PATTERNS FOR KEEP-ALIVE
-----------------------------
The NGIO.keepAliveTimer handles automatic session maintenance. Choose the 
pattern that matches your platform's capabilities:

PATTERN 1: Native Timers (PREFERRED)
If your platform has timer/scheduler APIs:
- JavaScript: setInterval(callback, milliseconds)
- Python: threading.Timer or asyncio
- C#: System.Threading.Timer or async Task.Delay
- Java: ScheduledExecutorService
- Unity: Coroutines with WaitForSeconds

PATTERN 2: Manual Throttling (FALLBACK)
If timers aren't available or reliable:
- Set keepAliveTimer to null (disable automatic mode)
- Use lastKeepAliveTime for manual throttling 
- Call NGIO.keepAlive() from your game's update loop
- Check if KEEP_ALIVE_TIME seconds have elapsed since last call

PATTERN 3: No Keep-Alive (SIMPLE, NOT RECOMMENDED!)
For simple games with short sessions:
- Omit timer implementation entirely
- Sessions will expire after inactivity (usually 1 hour)
- Users will need to re-authenticate if expired

URL OPENING SECURITY RESTRICTIONS
---------------------------------
Many platforms restrict programmatic URL opening for security:

WEB BROWSERS:
- Must be triggered by user interaction (click, touch, key press)
- Cannot be called from timer callbacks or async responses
- Solution: Show "Login" button that calls NGIO.openPassport()

MOBILE APPS (iOS/Android):
- May require permission declarations in manifest
- Some app stores restrict external URL opening
- Solution: Use in-app browser or WebView when possible

DESKTOP APPLICATIONS:
- Usually unrestricted, but may show security warnings
- Solution: Inform user before opening external URLs

GAME ENGINES:
- Varies by platform and distribution (Steam, web, mobile)
- Solution: Check engine documentation for URL opening APIs

TIMESTAMP HANDLING VARIATIONS
-----------------------------
The pseudo-code uses "Timestamp" for time values. Platform translations:

- JavaScript: Date object or number (milliseconds since epoch)
- Python: datetime object or time.time() float
- C#: DateTime or DateTimeOffset
- Java: Instant, LocalDateTime, or long milliseconds
- Unity: DateTime (avoid float Time.time for network operations)

Choose the type that best integrates with your platform's time APIs.

PERSISTENT STORAGE PATTERNS
---------------------------
AppState requires persistent storage to save session IDs between app sessions.
The pseudo-code uses generic storage functions that map to platform storage:

WEB BROWSERS:
- GET_FROM_PERSISTENT_STORAGE() → localStorage.getItem()
- SAVE_TO_PERSISTENT_STORAGE() → localStorage.setItem()
- CLEAR_FROM_PERSISTENT_STORAGE() → localStorage.removeItem()

MOBILE APPS (iOS/Android):
- Use platform keychain/SharedPreferences for security
- iOS: Keychain Services or UserDefaults
- Android: SharedPreferences or EncryptedSharedPreferences

DESKTOP APPLICATIONS:
- Windows: Registry or AppData folder files
- macOS: Plists or Application Support folder
- Linux: XDG config directories or dot files

GAME ENGINES:
- Unity: PlayerPrefs (automatic platform mapping)
- Unreal: Game User Settings or Save Game system
- GameMaker: ini_open/ini_write functions

Choose storage that persists between app launches and is secure for session data.

DOMAIN DETECTION PATTERNS
-------------------------
AppState needs to detect the current domain/host for domain-restricted apps.
The pseudo-code uses GET_CURRENT_DOMAIN() which maps to platform APIs:

WEB BROWSERS:
- JavaScript: window.location.hostname or window.location.host
- IMPORTANT: Extract base domain only - remove ALL subdomains
- Examples: www.example.com → example.com, api.example.com → example.com, sub.api.example.com → example.com
- Algorithm: Split by dots, keep only the last two components (domain + TLD)
- Exception: Handle special cases like .co.uk (two-part TLDs) if needed for your use case

MOBILE APPS:
- iOS: Bundle.main.bundleIdentifier (app bundle ID)  
- Android: applicationContext.packageName
- Use consistent identifier across app versions

DESKTOP APPLICATIONS:
- May not have meaningful "domain" concept
- Use application identifier or "localhost" as default
- Consider command-line arguments for domain override

GAME ENGINES:
- Unity: Application.identifier or custom configuration
- Check for runtime platform (WebGL vs standalone)
- May need platform-specific conditional logic

Use "N/A" as fallback when domain detection unavailable or not applicable.

================================================================================
COMMON PITFALLS
================================================================================

1. REPLACING OBJECT REFERENCES
   ✗ Wrong: appState.session = newSessionObject
   ✓ Right: appState.session.importFromObject(data)
   Why: External code loses references if you replace objects

2. NOT CHECKING hasLoaded()
   ✗ Wrong: Immediately call NGIO.getMedal(5) after init
   ✓ Right: Call loadMedals(), wait for callback, then get medal
   Why: Data isn't loaded until server responds

3. TRUSTING UNVERIFIED SESSIONS
   ✗ Wrong: Use session.user immediately after loading from storage
   ✓ Right: Call checkSession(), wait for validation, then use user
   Why: Session might have expired since last use

4. FORGETTING ENCRYPTION
   ✗ Wrong: Send secure components as plain JSON
   ✓ Right: Check isSecure and encrypt if true
   Why: Server rejects unencrypted secure components

5. BLOCKING ON ASYNC OPERATIONS
   ✗ Wrong: Wait/block until network request completes
   ✓ Right: Use callbacks/promises/async-await properly
   Why: Blocking freezes apps and is often impossible anyway

6. HARD-CODING ERROR MESSAGES
   ✗ Wrong: if (error.code === 104) display "Session expired"
   ✓ Right: Use Errors.getDefaultMessage(error.code)
   Why: Centralized messages can be updated/localized


================================================================================
BEST PRACTICES
================================================================================

CODE STYLE
----------
1. Follow your language's official style guide
2. Use descriptive variable names (not abbreviated)
3. Comment complex logic (encryption, state updates)
4. Include doc comments on all public methods
5. Use type hints where available

ERROR HANDLING
--------------
1. Never let network errors crash the app
2. Always provide error info to callback/promise
3. Log errors for debugging (use proper logging, not console)
4. Provide sensible defaults when data unavailable

PERFORMANCE
-----------
1. Batch multiple components in one request when possible
2. Cache data aggressively (that's what AppState is for)
3. Don't poll excessively (checkSession every 2-3 seconds max)
4. Consider background queuing for non-urgent operations

SECURITY
--------
1. Never log or display encryption keys
2. Use HTTPS only (gateway enforces this)
3. Store session IDs securely on mobile platforms
4. Don't trust client-side data for secure operations

DOCUMENTATION
-------------
1. Include setup guide with app ID and encryption key instructions
2. Document callback signatures clearly
3. Provide code examples for common operations
4. Explain session lifecycle and Passport flow
5. Note which methods require user authentication


================================================================================
GETTING HELP
================================================================================

OFFICIAL DOCUMENTATION:
- Developer Guide: https://github.com/PsychoGoldfishNG/ngio-developer-guide
- API Reference: https://www.newgrounds.io/help/
- Components: https://www.newgrounds.io/help/components/
- Objects: https://www.newgrounds.io/help/objects/
- Encryption: https://www.newgrounds.io/help/encryption/
- Passport: https://www.newgrounds.io/help/passport/

COMMUNITY SUPPORT:
- Discord Server: https://discord.gg/wcsCk2ErhH
  Get real-time support and hang out with other game developers
  
- Support Forum: https://www.newgrounds.com/bbs/topic/1412560
  Post questions and get help from the community
  Be patient - someone will respond as soon as possible


REMEMBER:
The pseudo-code files are guides, not strict rules. Adapt them to your
language's idioms and conventions while maintaining the core architecture
and design patterns. When in doubt, prioritize code that feels natural to
developers in your target language.

================================================================================
