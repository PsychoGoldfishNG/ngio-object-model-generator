<%  
/**
 * This template is written in EJS (Embedded JavaScript)
 * 
 * This allows you to execute javascript between `<%` and `%>` tags
 * 
 * If you open your tag with `<%`, anything rendered will not be printed to the output.
 * If you open your tag with `<%=`, anything rendered will be printed to the output, but safely escaped.
 * If you open your tag with `<%-`, anything rendered will be printed to the output, but NOT escaped (you typically want to use this when generating code).
 *
 * If you close your tag with `%>`, it will end javascript execution and return to the template.
 * If you close your tag with `-%>`, it will end javascript execution and return to the template, but also trim any trailing whitespace.
 */
-%>
<%
// The property rules are stored in the model.properties object
// with property names as keys and property definition objects as values.

// And we'll use this to get the key names for each property
const propertyNames = model.properties ? Object.keys(model.properties) : [];

// we'll use this to keep track of required properties
const requiredParams = [];
-%>

// IMPORT ANY UNIVERSAL DEPENDENCIES FOR OBJECT MODELS HERE
<%
/**
 * model.component is the component namespace for this object, and
 * model.method is the method name we are modeling.
 * 
 * For example, the Medal.unlock component and method would be:
 * model.component = "Medal"
 * model.method = "unlock"
 *
 * 
 * In your config file, you will set up the base path for any partials.
 * You can use partial.get (partial must exist) or partial.getIfExists (will do nothing if partial does not exist)
 * to include snippets of reusable template code by providing a path to the partial (relative to the base path), 
 * and an optional data object the partial can use for dynamic content.
 *
 * If this was the Medal.unlock component, the partial file being included would be:
 * {partials_dir}/components/Medal/unlock/imports.ejs
 */
-%>
<%- partial.getIfExists(`components/${model.component}/${model.method}/imports`) -%>

<%
/**
 * Start the class definition
 * 
 * Our helper module will help us format the component description into a multiline comment
 */
-%>
<%- helper.formatMultilineComment(model.description, `Used to call the ${model.component}.${model.method} component.
${model.description}`) %>
class newgroundsIO.models.components.<%- model.component %>.<%- model.method %> extends newgroundsIO.models.BaseComponent {
 
<%
/**
 * Here's an example loop where we define all of our properties in
 * private variables, prefixed with an underscore.
 * 
 * We will also track which properties are required while we're at it.
 * 
 * further down, we will create getter/setter methods for each property.
 */
-%>
<% if (propertyNames.length > 0) { -%>
<%   for(let prop in model.properties) { -%>
<%     // If this is a required property, add it to the list -%>
<%     if(model.properties[prop].required) requiredParams.push(prop); -%>

<%  // we're using our helper module to print the proper data type for this property -%>
    private var _<%- prop %>:<%- helper.getDataType(model.properties[prop]) %> = <%- model.properties[prop].default === undefined ? "null" : JSON.stringify(model.properties[prop].default) %>;

<%   } -%>
<% } -%>

<%
    // You can set any universal properties here...
-%>
    // the name of this component for identification/debugging
    public var componentName:String = "<%- model.component %>.<%- model.method %>";

    // the property names for this component, if you need to refer to them as an array
    public var propertyNames:Array<String> = <%- JSON.stringify(propertyNames) %>;

    // These properties are required for this component to be valid
    public var requiredParams:Array<String> = <%- JSON.stringify(requiredParams) %>;

    // If true, this component must be called as a secure object (using encryption)
    public var isSecure:Boolean = <%= model.secure ? "true" : "false" %>;

    // If true, this component only works with a valid user session
    public var requireSession:Boolean = <%= model.require_session ? "true" : "false" %>;

    // If true, this component should be launched in a new browser tab wich will redirect
    // the user to another URL after logging the referral
    public var isRedirect:Boolean = <%= model.redirect ? "true" : "false" %>;

<% // You can use partials to add custom, component-specific properties -%>
<%- partial.getIfExists(`components/${model.component}/${model.method}/properties`) -%>

<% // start the constructor -%>
    /**
     * Constructor
<% if (propertyNames.length > 0) { -%>
     * @param props An object of initial properties for this instance
<% } -%>
     */
    public function <%- model.method %>(<% if (propertyNames.length > 0) { %>props:Object<% } %>):Void
    {
        // call the parent constructor
        super();

<%      // is there any other constructor code we want to inject? -%>
<%-     partial.getIfExists(`components/${model.component}/${model.method}/constructor`) -%>

<% if (propertyNames.length > 0) { -%>
        // fill the properties with the initial values
        for (var prop:String in props) {
            // if the property is defined in this component, set it
            if (this.propertyNames.indexOf(prop) >= 0) {
                this[prop] = props[prop];
            } else {
                // otherwise, throw an error
                throw new Error("Property '" + prop + "' is not defined for component '" + this.componentName + "'.");
            }
        }
<% } -%>
    }

<% // Here is a sample loop to generate getter/setter methods -%>
<% if (propertyNames.length > 0) { -%>
<%   for(let prop in model.properties) { -%>

<%- helper.formatMultilineComment(model.properties[prop].description, "    ") %>
    public function get <%- prop %>():<%- helper.getDataType(model.properties[prop]) %>
    {
        return this._<%- prop %>;
    }
    
    public function set <%- prop %>(<%- prop %>:<%- helper.getDataType(model.properties[prop]) %>)
    {
<%
        /**
         * Add additional logic to the setter as needed.
         * 
         * Property definitions may have a few properties that will help you handle this bit.
         * 
         * if model.properties[prop].type is set, it will be a string like "string", "number", "boolean", etc, indicating
         *     the type of data this property should be.
         * 
         * if model.properties[prop].object is set, it will be one of our core object types like "Medal", "User", etc.
         *     This can be used to cast the data to the correct model.
         * 
         * if model.properties[prop].array is set, this property can be an array of values.  This will be an object
         *     containing either a type or an object property, similar to the above.
         * 
         * it is possible for a property to have an array value AND a type or object value.
         *     In this case, the value can either be a typed value, or an array of that same type.
         */
-%>

        this._<%- prop %> = <%- prop %>;
    }

<%   } -%>
<% } -%>

<% // You can use partials to add custom, component-specific methods -%>
<%- partial.getIfExists(`components/${model.component}/${model.method}/methods`) -%>

}